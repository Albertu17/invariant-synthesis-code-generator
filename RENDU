           Mini-projet 2 : Synthèse d'invariant en SMT-LIB
                            fichier RENDU
                     (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 15 décembre 2023 à 22:00

Identité
--------
Nombre de binôme: 16
Nom, prénom 1: De Larminat, Foucauld
Nom, prénom 2: Tomasi, Albert


Questions sur votre code
------------------------

** Exercice 2 **

0. Avez-vous testé que `make invariants` s'exécute sans erreurs ou
   warnings, puis que `./invariants` produit une sortie au format
   SMT-LIB, et enfin que cette sortie est acceptée par Z3 ?

**à remplir**

---

1. Le type `term` est un type récursif : quel type de fonction OCaml
   est-il naturel d'utiliser ? Quels sont vos cas de base et quelle
   quantité strictement décroissante au cours des appels successifs
   vous assure la terminaison ?

Fonction récursive avec pattern matching pour déconstruire ce type
récursif. 
 
Cas de base (pour str_of_term) : Const of Int | Var of Int. Pour ces deux
cas, on renvoie directement une chaîne de caractères sans faire de nouvel
appel à str_of_term. 
Pour les autres cas, à chaque appel de la fonction, la longeur du terme
passé en paramètre diminue (de 1 si match avec Const | Var, de 2 si match
avec Add | Mult). Ainsi il n'y aura jamais plus de n appels à str_of_term
(avec n étant le nombre de termes founis).


---

2. Pour l'implémentation de `str_condition`, quelles sont les
   fonctions auxiliaires que vous avez utilisées et/ou écrites ? (Par
   une fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length` ou
   `List.rev_append`, ou une fonction `aux_str_condition` que vous
   avez écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `str_condition`.

Pour l'implémentation de str_condition, nous avons utilisé les fonctions
auxiliaires suivantes:
. List.map, pour appliquer la fonction string_of_term aux éléments de la
liste de termes passée en argument.
. String.concat, pour concaténer ensuite les chaînes de caractères obtenues,
en insérant un espace entre chacune d'elles.

---

3. Pour l'implémentation de `str_assert_forall`, quelles sont les
   fonctions auxiliaires que vous avez utilisées et/ou écrites ?
   Expliquez en quelques phrases en français comment ces fonctions
   auxiliaires sont utilisées dans votre implémentation de la fonction
   `str_assert_forall`.

Pour l'implémentation de str_assert_forall, nous avons utilisé les fonctions
auxiliaires suivantes:
. x (fournie), pour obtenir la chaîne de caractères "xi" à partir de l'entier i.
. rec loop, pour exécuter l'opération précédente pour tous les entiers de 1 à n
(entier passé en argument), opérer le bon formatage et concaténer tous les résultas
entre eux.
. str_assert (fournie), pour faire précéder la chaîne de caractères finale
de la mention "assert".

---

4. Le langage de programmation WA suppose que les mises à jour des
   variables `x1`, ..., `xk` sont simultanées : par exemple, si `x1`
   vaut `1` et x2 vaut `1`, exécuter

   x1 = x2 + 1;
   x2 = x1 + 1;

   résulte en `x1` valant `2` et `x2` valant `2`. En Java, les mises à
   jour sont séquentielles et le résultat serait que `x1` vaudrait `2`
   et `x2` vaudrait `3`. Expliquez comment modifier le code pour
   construire un programme SMT-LIB plus proche de la façon dont les
   variables sont mises à jour en Java.

La mise à jour précédente nécessite en Java l'utilisation d'une variable tampon
qui stocke la valeur de la première variable avant sa modification comme suivant : 

temp = x1 + 1;
x1 = x2 + 1;
x2 = temp;

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)


